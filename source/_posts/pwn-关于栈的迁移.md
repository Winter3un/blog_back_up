---
title: '[pwn] 关于栈的迁移'
date: 2016-05-20 08:29:04
tags: 
 - pwn
 - bin
---


## [pwn] 关于栈的迁移

在我们仅仅只能够控制ebp的情况下，我们怎么才能够控制eip去拿到我们的shell呢。

### 以下为科普

以32位程序举例，在使用`call`这个命令，进入一个函数的时候,程序会进行一系列栈操作:
`push eip+4;push ebp;mov ebp,esp;`来保护现场，避免执行完函数后堆栈不平衡以及找不到之前的入口地址。

执行完函数后会进行一系列操作来还原现场`leave;ret;`
这边的leave就相当于进入函数栈操作的逆过程。
```
leave  == mov esp,ebp;pop ebp;
ret    == pop eip #弹出栈顶数据给eip寄存器
```

这样如果能够控制栈空间到任意地址，那么我们就能利用ret来控制eip的数据了（栈顶数据）

### 进入主题

这次我碰到的这题题目是来自于pwnable的login。
我们只能够控制ebp的数据，关键的返回地址的数据由于输入长度的限制并不能控制，然而我们还是可以通过控制ebp来绕过限制。

由于`ret`返回的是栈顶数据，而栈顶地址是由esp寄存器的值决定的，也就是说如果我们控制了esp寄存器的数据，那么我们也就能够控制ret返回的栈顶数据。

现在我们已经知道了 level能够将ebp寄存器的数据mov到esp寄存器中，然而，一开始ebp寄存器中的值并不是由我们来决定的，重点是接下来的那个`pop ebp`的操作，该操作将栈中保存的ebp数据赋值给了ebp寄存器，而我们正好能够控制该部分数据。所以利用思路便成立了。

我们首先将栈中保存ebp数据的地址空间控制为我们想要栈顶地址，再利用两次`leave`操作`mov esp,ebp;pop ebp;mov esp,ebp;pop ebp;`将esp寄存器中的值变成我们想让它成为的值。由于最后还有一个`pop ebp`操作多余，该操作将导致`esp-4`，所以在构造ret的数据时应当考虑到将数据放到我们构造的esp地址-4的位置。

**注意该利用需要两次leave哦~**